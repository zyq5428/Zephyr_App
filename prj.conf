#
# Kernel & System (内核与系统基础)
#
# 定义系统时钟滴答的频率
CONFIG_SYS_CLOCK_TICKS_PER_SEC=1000
# 启用 Newlib C 库
CONFIG_NEWLIB_LIBC=y

#
# 控制台
#
# --- 基础控制台支持 ---
CONFIG_CONSOLE=y
# 启用控制台输入处理,既然用了 Shell，就不需要原始的控制台处理器了
CONFIG_CONSOLE_HANDLER=n
# 控制台最大输入行长度
CONFIG_CONSOLE_INPUT_MAX_LINE_LEN=128
# 启用标准输出重定向到控制台，允许 printf 等通过控制台(此时是 Shell)输出
CONFIG_STDOUT_CONSOLE=y
# 指定 UART 作为控制台设备,不要让 Console 直接写 UART，而是交给 Shell 统一管
CONFIG_UART_CONSOLE=n

#
# Subsystems: Shell and Console (外壳与控制台)
#
# 启用 Shell 子系统
CONFIG_SHELL=y
# 启用 Shell 后端支持
CONFIG_SHELL_BACKENDS=y
# 使用串口作为 Shell 的 I/O 接口
CONFIG_SHELL_BACKEND_SERIAL=y
# 这一行是关键！它会让 Shell 注册为系统的一个 Console 驱动
CONFIG_SHELL_BACKEND_SERIAL_INTERRUPT_DRIVEN=y
# 解决争抢：让 Shell 接管日志后端输出
CONFIG_SHELL_LOG_BACKEND=y
# 启用 UART 运行时配置更改
CONFIG_UART_USE_RUNTIME_CONFIGURE=y
# 增加 Shell 线程栈大小以确保稳定运行
CONFIG_SHELL_STACK_SIZE=2048
# 开启内核对象查询（必须）
CONFIG_THREAD_MONITOR=y
# 开启线程名显示（方便识别是哪个任务）
CONFIG_THREAD_NAME=y
# 开启栈分析功能（查看具体使用了百分之几）
CONFIG_THREAD_STACK_INFO=y
CONFIG_THREAD_ANALYZER=y

#
# Logging System (日志系统)
#
# 启用核心日志功能
CONFIG_LOG=y
# 强制日志立即同步输出，不要缓存
CONFIG_LOG_MODE_IMMEDIATE=y
# 启用延迟模式（使用队列，提高实时性能）
# CONFIG_LOG_MODE_DEFERRED=y
# 使用 UART 作为日志输出后端;禁用原生的日志 UART 后端（避免重复）
CONFIG_LOG_BACKEND_UART=n
# 默认日志级别设置为 Info (3)
CONFIG_LOG_DEFAULT_LEVEL=3
# 编译时包含的最大日志级别设置为 Debug (4)
CONFIG_LOG_MAX_LEVEL=4
# 增加打印延迟，防止刷屏导致系统假死
CONFIG_LOG_BUFFER_SIZE=2048

#
# Core Drivers: Serial/UART (核心驱动：串行/UART)
#
# 启用串行子系统
CONFIG_SERIAL=y
# 启用中断驱动模式 (高效)
CONFIG_UART_INTERRUPT_DRIVEN=y

# 启用浮点支持，以便在日志中打印浮点数
CONFIG_CBPRINTF_FP_SUPPORT=y

# 启用 DMA 核心支持
CONFIG_DMA=y

# 启用 PWM
CONFIG_PWM=y
CONFIG_PWM_STM32=y

#
# Core Drivers: GPIO (通用输入/输出)
#
# 启用 GPIO 核心支持
CONFIG_GPIO=y
# 启用 STM32 硬件 GPIO 驱动
CONFIG_GPIO_STM32=y

#
# Core Drivers: I2C
#
# 启用 I2C 核心支持
CONFIG_I2C=y
# 开启软件模拟 I2C 驱动
CONFIG_I2C_GPIO=y
# 启用 STM32 硬件 I2C 驱动
CONFIG_I2C_STM32=y
# 启用中断驱动模式
CONFIG_I2C_STM32_INTERRUPT=y

#
# Core Drivers: QSPI/Flash (W25Q128)
#
# 启用 Flash API 核心支持
# CONFIG_FLASH=y
# 启用使用 STM32 HAL 库实现的 QSPI 驱动
# CONFIG_FLASH_STM32_QSPI=y

#
# Core Drivers: Standard SPI
#
# 启用标准 SPI 核心支持 (如果需要连接 SPI 传感器/屏幕)
CONFIG_SPI=y
CONFIG_SPI_STM32=y
# 暂时关闭 SPI DMA 传输，强制使用轮询/中断模式
# CONFIG_SPI_STM32_DMA=n
# 启用 SPI DMA 传输
CONFIG_SPI_STM32_DMA=y
# 建议开启日志以便调试
# CONFIG_SPI_LOG_LEVEL_DBG=y

#
# Core Drivers: RTC (实时时钟)
#
# 启用 RTC 核心支持
CONFIG_RTC=y
# 启用 STM32 硬件 RTC 驱动
CONFIG_RTC_STM32=y
# 启用 RTC 闹钟功能
CONFIG_RTC_ALARM=y

#
# Core Drivers: LED (发光二极管)
#
# 启用 LED 核心驱动框架
CONFIG_LED=y
# 启用 GPIO LED 驱动 (用于开关控制)
CONFIG_LED_GPIO=y
# 启用 PWM LED 驱动 (用于亮度调节)
CONFIG_LED_PWM=y

#
# Core Drivers: Pin Controller and HW Info (引脚控制器与硬件信息)
#
# 启用引脚控制器核心支持
CONFIG_PINCTRL=y
# 启用 STM32 引脚控制器驱动
CONFIG_PINCTRL_STM32=y
# 启用硬件信息核心支持
CONFIG_HWINFO=y
# 启用 STM32 硬件信息驱动 (读取芯片ID等)
CONFIG_HWINFO_STM32=y

#
# 12. Display Driver (显示驱动 - LCD)
#
# 启用显示子系统
CONFIG_DISPLAY=y

# 使用 SSD1306 OLED 驱动 (I2C)
# Disable Zephyr built-in SSD1306 driver to use our custom driver
# CONFIG_SSD1306 is not set

# LVGL GUI
CONFIG_LVGL=y
# LVGL初始化会复用main stack，因此需要增加 main stack size
CONFIG_MAIN_STACK_SIZE=2048
# LVGL 颜色深度设置
# CONFIG_LV_COLOR_DEPTH_1=y
# LVGL 内存池大小设置 (16 KB)
CONFIG_LV_Z_MEM_POOL_SIZE=16384
# 绘图缓冲区（画布大小，128x16 像素，约 256 字节 RAM）
CONFIG_LV_Z_VDB_SIZE=10
# 启用 Montserrat 字体支持
CONFIG_LV_FONT_MONTSERRAT_24=y
CONFIG_LV_FONT_MONTSERRAT_32=y
CONFIG_LV_FONT_MONTSERRAT_48=y
# 启用 16 位颜色字节交换 (RGB565 格式)
# 如果不开启 SWAP:数据存储顺序可能是 [高8位] [低8位](Big Endian)。
# 开启 SWAP 后：数据会被软件强制变成 [低8位] [高8位](Little Endian)。
# SPI 接口发送数据通常是按字节发送的,如果MCU是小端模式(Little Endian),
# 而屏幕期望的是大端数据（或者反过来）,像素传过去后,字节顺序反了.
# 现象:屏幕能显示图像,但颜色非常诡异,像杂色、花屏,或者颜色有颗粒感.
CONFIG_LV_COLOR_16_SWAP=y
# LVGL默认字体设置
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_8=y
# LVGL组件开关(默认开启了很多组件，根据需要关闭)
# CONFIG_LV_USE_LABEL=n
# 开启LVGL Demo
CONFIG_LV_BUILD_DEMOS=y
# 开启基础控件 Demo
CONFIG_LV_USE_DEMO_WIDGETS=y
# 开启基准测试 Demo
# CONFIG_LV_USE_DEMO_BENCHMARK=y
# 智能手表 Demo
# CONFIG_LV_USE_DEMO_SMARTWATCH=y
# --- 必须开启的核心统计开关 ---
# 这个开关允许 Zephyr 追踪堆内存的使用情况
CONFIG_SYS_HEAP_RUNTIME_STATS=y
# 启用 LVGL 监控功能
CONFIG_LV_USE_SYSMON=y
# 允许 LVGL 监控内存使用情况(自带的适合大屏幕，小屏幕用不了)
# CONFIG_LV_USE_MEM_MONITOR=y
# 提高 LVGL 自身的日志级别，观察它在初始化驱动时到底卡在哪了
CONFIG_LV_USE_LOG=y
# CONFIG_LV_LOG_LEVEL_TRACE=y

# 启用 ST7789V 驱动程序
# CONFIG_ST7789V=y

# 启用 MIPI DBI 子系统 (MIPI Display Bus Interface)
# CONFIG_MIPI_DBI=y

# 启用 MIPI DBI 的 SPI 模式实现
# CONFIG_MIPI_DBI_SPI=y

# Display 日志级别
# CONFIG_DISPLAY_LOG_LEVEL_DBG=y
# CONFIG_I2C_LOG_LEVEL_DBG=y
# CONFIG_SPI_LOG_LEVEL_DBG=y

